# Introduction #

Здесь представлены замечания по реализации нахождения всех пересечений отрезков

# Details #

  * Необходимо производить сортировку по той точке, которая имеет меньшую абсциссу (пока рассматривая только точку 1)

  * Предусмотреть класс для хранения отрезков - контейнер.

  * Что использовать в контейнерах, указатель или объект и **`const`** или нет?

  * Проблема: не могу в классе объявить объект сортировки, а потом с его помощью объявить map. Похожая проблема для priority\_queue. Как быть с собственной функцией сортировки???

  * Для вектора **`LexSortPoints`** работает нормально, для приоритетной очереди - не понятно как; вроде, сортирует по убыванию, но иногда этот порядок нарушается.

  * Вместо приоритетной очереди сделал список, т.к. не могу разобраться с сортировкой в приоритетной очереди. Возможно, надо отказаться и от map, т.к., похоже, что в нем сортировка осуществляется по ключам, а не по значениям. Вместо него использовать list и добавить в **`Segment`** поле **`numSegment`**.

  * Возможно, поручить создание объектов **`EndPoint`** классу `Segment` и в нем определять тип точки (правая или левая). Подумать над реализацией функций **`leftPoint()`** и **`rightPoint()`**.

  * Сделать контейнер для хранения списка отрезков. Отрезки хранить в **`map<int, Segment>`**

  * Ошибка во время исполнения (что-то с кучей) после удаления **`qlfSweepLine`** в деструкторе **`SortSegments`**. Почему не понятно!!!

  * Выяснилось, что нужно по точке пересечения находить пересекающиеся в ней отрезки. Здесь можно добавить точку пересечения к двум отрезкам и хранить это в структуре данных; можно находить точку пересечения каждой пары и сравнивать ее с заданной; можно хранить в `EndPoint` список номеров отрезков, пересекающихся в этой точке. Для случая, когда в точке могут пересекаться не более 2х отрезков, проблем нет, но если там пересекается больше 2х отрезков, то одна и та же точка пересечения будет соответствовать нескольким парам отрезков.

  * Необходимо как-то определять s1 НАД s2 слева от p

  * У меня координаты точки пересечения имеют тип **`int`**, но не всегда точка пересечения будет целой... зависит ли от этого работа алгоритма?

  * Нашел причину, по которой не работал алгоритм - при обработке точки пересечения не выполнялась замена местами s1 и s2. Сделал замену, на данном примере стал нормально работать.

  * Обязательно разобраться, как работает **`swap(const Segment*, const Segment*)`** - по-идее, в **`SegmentSpace::SegmentContainer::mapSegments`** должны произойти некорректные изменения указателей, но этого, как я понял, не происходит.

  * Возможно, стоит в поиске пересечений оперировать с номерами отрезков, а на с самими отрезками

  * Подумать над условием вывода пересечения и вставки точки пересечения в список точек событий. Также решить, что значит точки равны друг другу

  * Определиться с пространствами имен. Возможно, поместить все классы, связанные с поиском всех пересесчений поместить в пространство **`SegmentSpace`**

  * Подумать над заменой классов **`LexSortPoints`** и **`SortSegments`** на **`operator<`**

  * Как обновлять информацию о новом положении отрезка в **`SegmentContainer`**. Можно сделать, например,  чтобы функция **`SegmentContainer::addSegment()`** возвращала **`int`** (при неудачной вставке -1)